{"version":3,"file":"Tabs.dkNXhqZm.js","sources":["../../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/crossfader.js","../../../node_modules/framer-motion/dist/es/animation/animate.js","../../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/stack.js","../../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js","../../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/rotate.js","../../../app/components/Tab.tsx","../../../app/components/Tabs.tsx"],"sourcesContent":["import { __assign } from 'tslib';\nimport sync, { getFrameData } from 'framesync';\nimport { mix, progress, linear, mixColor, circOut } from 'popmotion';\nimport { animate } from '../../../animation/animate.js';\nimport { getValueTransition } from '../../../animation/utils/transitions.js';\nimport { motionValue } from '../../../value/index.js';\n\nfunction createCrossfader() {\n    /**\n     * The current state of the crossfade as a value between 0 and 1\n     */\n    var progress = motionValue(1);\n    var options = {\n        lead: undefined,\n        follow: undefined,\n        crossfadeOpacity: false,\n        preserveFollowOpacity: false,\n    };\n    var prevOptions = __assign({}, options);\n    var leadState = {};\n    var followState = {};\n    /**\n     *\n     */\n    var isActive = false;\n    /**\n     *\n     */\n    var finalCrossfadeFrame = null;\n    /**\n     * Framestamp of the last frame we updated values at.\n     */\n    var prevUpdate = 0;\n    function startCrossfadeAnimation(target, transition) {\n        var lead = options.lead, follow = options.follow;\n        isActive = true;\n        finalCrossfadeFrame = null;\n        var hasUpdated = false;\n        var onUpdate = function () {\n            hasUpdated = true;\n            lead && lead.scheduleRender();\n            follow && follow.scheduleRender();\n        };\n        var onComplete = function () {\n            isActive = false;\n            /**\n             * If the crossfade animation is no longer active, flag a frame\n             * that we're still allowed to crossfade\n             */\n            finalCrossfadeFrame = getFrameData().timestamp;\n        };\n        transition = transition && getValueTransition(transition, \"crossfade\");\n        return animate(progress, target, __assign(__assign({}, transition), { onUpdate: onUpdate, onComplete: function () {\n                if (!hasUpdated) {\n                    progress.set(target);\n                    /**\n                     * If we never ran an update, for instance if this was an instant transition, fire a\n                     * simulated final frame to ensure the crossfade gets applied correctly.\n                     */\n                    sync.read(onComplete);\n                }\n                else {\n                    onComplete();\n                }\n                onUpdate();\n            } }));\n    }\n    function updateCrossfade() {\n        var _a, _b;\n        /**\n         * We only want to compute the crossfade once per frame, so we\n         * compare the previous update framestamp with the current frame\n         * and early return if they're the same.\n         */\n        var timestamp = getFrameData().timestamp;\n        var lead = options.lead, follow = options.follow;\n        if (timestamp === prevUpdate || !lead)\n            return;\n        prevUpdate = timestamp;\n        /**\n         * Merge each component's latest values into our crossfaded state\n         * before crossfading.\n         */\n        var latestLeadValues = lead.getLatestValues();\n        Object.assign(leadState, latestLeadValues);\n        var latestFollowValues = follow\n            ? follow.getLatestValues()\n            : options.prevValues;\n        Object.assign(followState, latestFollowValues);\n        var p = progress.get();\n        /**\n         * Crossfade the opacity between the two components. This will result\n         * in a different opacity for each component.\n         */\n        var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n        var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n        if (options.crossfadeOpacity && follow) {\n            leadState.opacity = mix(\n            /**\n             * If the follow child has been completely hidden we animate\n             * this opacity from its previous opacity, but otherwise from completely transparent.\n             */\n            follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n            followState.opacity = options.preserveFollowOpacity\n                ? followTargetOpacity\n                : mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n        }\n        else if (!follow) {\n            leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);\n        }\n        mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n    }\n    return {\n        isActive: function () {\n            return leadState &&\n                (isActive || getFrameData().timestamp === finalCrossfadeFrame);\n        },\n        fromLead: function (transition) {\n            return startCrossfadeAnimation(0, transition);\n        },\n        toLead: function (transition) {\n            var initialProgress = 0;\n            if (!options.prevValues && !options.follow) {\n                /**\n                 * If we're not coming from anywhere, start at the end of the animation.\n                 */\n                initialProgress = 1;\n            }\n            else if (prevOptions.lead === options.follow &&\n                prevOptions.follow === options.lead) {\n                /**\n                 * If we're swapping follow/lead we can reverse the progress\n                 */\n                initialProgress = 1 - progress.get();\n            }\n            progress.set(initialProgress);\n            return startCrossfadeAnimation(1, transition);\n        },\n        reset: function () { return progress.set(1); },\n        stop: function () { return progress.stop(); },\n        getCrossfadeState: function (element) {\n            updateCrossfade();\n            if (element === options.lead) {\n                return leadState;\n            }\n            else if (element === options.follow) {\n                return followState;\n            }\n        },\n        setOptions: function (newOptions) {\n            prevOptions = options;\n            options = newOptions;\n            leadState = {};\n            followState = {};\n        },\n        getLatestValues: function () {\n            return leadState;\n        },\n    };\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = \"border\" + borders[i] + \"Radius\";\n        var followRadius = getRadius(latestFollowValues, borderLabel);\n        var leadRadius = getRadius(latestLeadValues, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        /**\n         * Currently we're only crossfading between numerical border radius.\n         * It would be possible to crossfade between percentages for a little\n         * extra bundle size.\n         */\n        if (typeof followRadius === \"number\" &&\n            typeof leadRadius === \"number\") {\n            var radius = Math.max(mix(followRadius, leadRadius, p), 0);\n            leadState[borderLabel] = followState[borderLabel] = radius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (latestFollowValues.rotate || latestLeadValues.rotate) {\n        var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n        leadState.rotate = followState.rotate = rotate;\n    }\n    /**\n     * We only want to mix the background color if there's a follow element\n     * that we're not crossfading opacity between. For instance with switch\n     * AnimateSharedLayout animations, this helps the illusion of a continuous\n     * element being animated but also cuts down on the number of paints triggered\n     * for elements where opacity is doing that work for us.\n     */\n    if (!hasFollowElement &&\n        latestLeadValues.backgroundColor &&\n        latestFollowValues.backgroundColor) {\n        /**\n         * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n         * We could probably create a mixer that runs at the start of the animation but\n         * the idea behind the crossfader is that it runs dynamically between two potentially\n         * changing targets (ie opacity or borderRadius may be animating independently via variants)\n         */\n        leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nexport { createCrossfader };\n","import { motionValue } from '../value/index.js';\nimport { isMotionValue } from '../value/utils/is-motion-value.js';\nimport { startAnimation } from './utils/transitions.js';\n\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */\nfunction animate(from, to, transition) {\n    if (transition === void 0) { transition = {}; }\n    var value = isMotionValue(from) ? from : motionValue(from);\n    startAnimation(\"\", value, to, transition);\n    return {\n        stop: function () { return value.stop(); },\n    };\n}\n\nexport { animate };\n","import { __assign } from 'tslib';\nimport { Presence } from '../types.js';\nimport { elementDragControls } from '../../../gestures/drag/VisualElementDragControls.js';\nimport { createCrossfader } from './crossfader.js';\n\nfunction layoutStack() {\n    var stack = new Set();\n    var state = { leadIsExiting: false };\n    var prevState = __assign({}, state);\n    var prevValues;\n    var prevViewportBox;\n    var prevDragCursor;\n    var crossfader = createCrossfader();\n    var needsCrossfadeAnimation = false;\n    function getFollowViewportBox() {\n        return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n    }\n    function getFollowLayout() {\n        var _a;\n        return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n    }\n    return {\n        add: function (element) {\n            element.setCrossfader(crossfader);\n            stack.add(element);\n            /**\n             * Hydrate new element with previous drag position if we have one\n             */\n            if (prevDragCursor)\n                element.prevDragCursor = prevDragCursor;\n            if (!state.lead)\n                state.lead = element;\n        },\n        remove: function (element) {\n            stack.delete(element);\n        },\n        getLead: function () { return state.lead; },\n        updateSnapshot: function () {\n            if (!state.lead)\n                return;\n            prevValues = crossfader.isActive()\n                ? crossfader.getLatestValues()\n                : state.lead.getLatestValues();\n            prevViewportBox = state.lead.prevViewportBox;\n            var dragControls = elementDragControls.get(state.lead);\n            if (dragControls && dragControls.isDragging) {\n                prevDragCursor = dragControls.cursorProgress;\n            }\n        },\n        clearSnapshot: function () {\n            prevDragCursor = prevViewportBox = undefined;\n        },\n        updateLeadAndFollow: function () {\n            var _a;\n            prevState = __assign({}, state);\n            var lead;\n            var follow;\n            var order = Array.from(stack);\n            for (var i = order.length; i--; i >= 0) {\n                var element = order[i];\n                if (lead)\n                    follow !== null && follow !== void 0 ? follow : (follow = element);\n                lead !== null && lead !== void 0 ? lead : (lead = element);\n                if (lead && follow)\n                    break;\n            }\n            state.lead = lead;\n            state.follow = follow;\n            state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n            crossfader.setOptions({\n                lead: lead,\n                follow: follow,\n                prevValues: prevValues,\n                crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot),\n            });\n            if (\n            // Don't crossfade if we've just animated back from lead and switched the\n            // old follow to the new lead.\n            state.lead !== prevState.follow &&\n                (prevState.lead !== state.lead ||\n                    prevState.leadIsExiting !== state.leadIsExiting)) {\n                needsCrossfadeAnimation = true;\n            }\n        },\n        animate: function (child, shouldCrossfade) {\n            var _a;\n            if (shouldCrossfade === void 0) { shouldCrossfade = false; }\n            if (child === state.lead) {\n                if (shouldCrossfade) {\n                    /**\n                     * Point a lead to itself in case it was previously pointing\n                     * to a different visual element\n                     */\n                    child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(true);\n                }\n                var config = {};\n                var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n                if (prevParent) {\n                    /**\n                     * We'll use this to determine if the element or its layoutId has been reparented.\n                     */\n                    config.prevParent = prevParent;\n                }\n                if (child.presence === Presence.Entering) {\n                    config.originBox = getFollowViewportBox();\n                }\n                else if (child.presence === Presence.Exiting) {\n                    config.targetBox = getFollowLayout();\n                }\n                if (needsCrossfadeAnimation) {\n                    needsCrossfadeAnimation = false;\n                    var transition = child.getDefaultTransition();\n                    child.presence === Presence.Entering\n                        ? crossfader.toLead(transition)\n                        : crossfader.fromLead(transition);\n                }\n                child.notifyLayoutReady(config);\n            }\n            else {\n                if (shouldCrossfade) {\n                    state.lead && child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(false);\n                }\n            }\n        },\n    };\n}\n\nexport { layoutStack };\n","import { __extends, __assign } from 'tslib';\nimport * as React from 'react';\nimport { Presence } from './types.js';\nimport { layoutStack } from './utils/stack.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { resetRotate } from './utils/rotate.js';\nimport { createBatcher } from './utils/batcher.js';\nimport { snapshotViewportBox } from '../../render/dom/projection/utils.js';\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    __extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = __assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.updateStacks();\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            layoutReady: function (child) {\n                if (child.getLayoutId() !== undefined) {\n                    var stack = _this.getStack(child);\n                    stack.animate(child, type === \"crossfade\");\n                }\n                else {\n                    child.notifyLayoutReady();\n                }\n            },\n            parent: this.context.visualElement,\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Write: Reset transforms so bounding boxes can be accurately measured.\n         */\n        this.children.forEach(function (child) {\n            resetRotate(child);\n            if (child.shouldResetTransform())\n                child.resetTransform();\n        });\n        /**\n         * Read: Snapshot children\n         */\n        this.children.forEach(snapshotViewportBox);\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         *\n         * TODO: What would be better here is doing a single loop where we\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (child) {\n        var id = child.getLayoutId();\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (React.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    AnimateSharedLayout.contextType = MotionContext;\n    return AnimateSharedLayout;\n}(React.Component));\n\nexport { AnimateSharedLayout };\n","import { transformAxes } from '../../../render/html/utils/transform.js';\n\nfunction resetRotate(child) {\n    // If there's no detected rotation values, we can early return without a forced render.\n    var hasRotate = false;\n    // Keep a record of all the values we've reset\n    var resetValues = {};\n    // Check the rotate value of all axes and reset to 0\n    for (var i = 0; i < transformAxes.length; i++) {\n        var axis = transformAxes[i];\n        var key = \"rotate\" + axis;\n        // If this rotation doesn't exist as a motion value, then we don't\n        // need to reset it\n        if (!child.hasValue(key) || child.getStaticValue(key) === 0)\n            continue;\n        hasRotate = true;\n        // Record the rotation and then temporarily set it to 0\n        resetValues[key] = child.getStaticValue(key);\n        child.setStaticValue(key, 0);\n    }\n    // If there's no rotation values, we don't need to do any more.\n    if (!hasRotate)\n        return;\n    // Force a render of this element to apply the transform with all rotations\n    // set to 0.\n    child.syncRender();\n    // Put back all the values we reset\n    for (var key in resetValues) {\n        child.setStaticValue(key, resetValues[key]);\n    }\n    // Schedule a render for the next frame. This ensures we won't visually\n    // see the element with the reset rotate value applied.\n    child.scheduleRender();\n}\n\nexport { resetRotate };\n","import { m } from \"framer-motion\";\nimport { LocationDescriptor } from \"history\";\nimport isEqual from \"lodash/isEqual\";\nimport queryString from \"query-string\";\nimport * as React from \"react\";\nimport styled, { useTheme } from \"styled-components\";\nimport { s, hover } from \"@shared/styles\";\nimport NavLink from \"~/components/NavLink\";\n\ntype Props = Omit<React.ComponentProps<typeof NavLink>, \"children\"> & {\n  /**\n   * The path to match against the current location.\n   */\n  to: LocationDescriptor;\n  /**\n   * If true, the tab will only be active if the path matches exactly.\n   */\n  exact?: boolean;\n  /**\n   * If true, the tab will only be active if the query string matches exactly.\n   * By default query string parameters are ignored for location mathing.\n   */\n  exactQueryString?: boolean;\n  children?: React.ReactNode;\n};\n\nconst TabLink = styled(NavLink)`\n  position: relative;\n  display: inline-flex;\n  align-items: center;\n  font-weight: 500;\n  font-size: 14px;\n  cursor: var(--pointer);\n  color: ${s(\"textTertiary\")};\n  user-select: none;\n  margin-right: 24px;\n  padding: 6px 0;\n\n  &: ${hover} {\n    color: ${s(\"textSecondary\")};\n  }\n`;\n\nconst Active = styled(m.div)`\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  height: 3px;\n  width: 100%;\n  border-radius: 3px;\n  background: ${s(\"textSecondary\")};\n`;\n\nconst transition = {\n  type: \"spring\",\n  stiffness: 500,\n  damping: 30,\n};\n\nconst Tab: React.FC<Props> = ({\n  children,\n  exact,\n  exactQueryString,\n  ...rest\n}: Props) => {\n  const theme = useTheme();\n  const activeStyle = {\n    color: theme.textSecondary,\n  };\n\n  return (\n    <TabLink\n      {...rest}\n      exact={exact || exactQueryString}\n      activeStyle={activeStyle}\n    >\n      {(match, location) => (\n        <>\n          {children}\n          {match &&\n            (!exactQueryString ||\n              isEqual(\n                queryString.parse(location.search ?? \"\"),\n                queryString.parse(rest.to.search as string)\n              )) && (\n              <Active\n                layoutId=\"underline\"\n                initial={false}\n                transition={transition}\n              />\n            )}\n        </>\n      )}\n    </TabLink>\n  );\n};\n\nexport default Tab;\n","import { AnimateSharedLayout } from \"framer-motion\";\nimport { transparentize } from \"polished\";\nimport * as React from \"react\";\nimport styled from \"styled-components\";\nimport { s } from \"@shared/styles\";\nimport useWindowSize from \"~/hooks/useWindowSize\";\n\nconst Nav = styled.nav<{ $shadowVisible?: boolean }>`\n  border-bottom: 1px solid ${s(\"divider\")};\n  margin: 12px 0;\n  overflow-y: auto;\n  white-space: nowrap;\n\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n\n  &::-webkit-scrollbar {\n    display: none;\n  }\n\n  &:after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 50px;\n    height: 100%;\n    pointer-events: none;\n    background: ${(props) =>\n      props.$shadowVisible\n        ? `linear-gradient(\n      90deg,\n      ${transparentize(1, props.theme.background)} 0%,\n      ${props.theme.background} 100%\n    )`\n        : `transparent`};\n  }\n`;\n\n// When sticky we need extra background coverage around the sides otherwise\n// items that scroll past can \"stick out\" the sides of the heading\nconst Sticky = styled.div`\n  position: sticky;\n  top: 54px;\n  margin: 0 -8px;\n  padding: 0 8px;\n  background: ${s(\"background\")};\n  z-index: 1;\n`;\n\nexport const Separator = styled.span`\n  border-left: 1px solid ${s(\"divider\")};\n  position: relative;\n  top: 2px;\n  margin-right: 24px;\n  margin-top: 6px;\n`;\n\ntype Props = {\n  children?: React.ReactNode;\n};\n\nconst Tabs: React.FC = ({ children }: Props) => {\n  const ref = React.useRef<any>();\n  const [shadowVisible, setShadow] = React.useState(false);\n  const { width } = useWindowSize();\n\n  const updateShadows = React.useCallback(() => {\n    const c = ref.current;\n    if (!c) {\n      return;\n    }\n    const scrollLeft = c.scrollLeft;\n    const wrapperWidth = c.scrollWidth - c.clientWidth;\n    const fade = !!(wrapperWidth - scrollLeft !== 0);\n\n    if (fade !== shadowVisible) {\n      setShadow(fade);\n    }\n  }, [shadowVisible]);\n\n  React.useEffect(() => {\n    updateShadows();\n  }, [width, updateShadows]);\n\n  return (\n    <AnimateSharedLayout>\n      <Sticky>\n        <Nav ref={ref} onScroll={updateShadows} $shadowVisible={shadowVisible}>\n          {children}\n        </Nav>\n      </Sticky>\n    </AnimateSharedLayout>\n  );\n};\n\nexport default Tabs;\n"],"names":["createCrossfader","progress","motionValue","options","lead","follow","crossfadeOpacity","preserveFollowOpacity","prevOptions","__assign","leadState","followState","isActive","finalCrossfadeFrame","prevUpdate","startCrossfadeAnimation","target","transition","hasUpdated","onUpdate","scheduleRender","onComplete","getFrameData","timestamp","getValueTransition","animate","from","to","value","isMotionValue","startAnimation","stop","set","sync","read","updateCrossfade","_a","_b","latestLeadValues","getLatestValues","Object","assign","latestFollowValues","prevValues","p","get","leadTargetOpacity","opacity","followTargetOpacity","mix","isVisible","easeCrossfadeIn","easeCrossfadeOut","mixValues","hasFollowElement","i","numBorders","borderLabel","borders","followRadius","getRadius","leadRadius","radius","Math","max","rotate","backgroundColor","mixColor","Boolean","fromLead","toLead","initialProgress","reset","getCrossfadeState","element","setOptions","newOptions","compress","circOut","linear","min","easing","length","values","radiusName","borderRadius","layoutStack","prevViewportBox","prevDragCursor","stack","Set","state","leadIsExiting","prevState","crossfader","needsCrossfadeAnimation","add","setCrossfader","remove","delete","getLead","updateSnapshot","dragControls","elementDragControls","isDragging","cursorProgress","clearSnapshot","updateLeadAndFollow","order","Array","presence","Presence","Exiting","isPresenceRoot","child","shouldCrossfade","pointTo","setVisibility","config","prevParent","getProjectionParent","Entering","originBox","getFollowViewportBox","targetBox","getFollowLayout","getLayoutState","layout","getDefaultTransition","notifyLayoutReady","AnimateSharedLayout","_super","_this","apply","this","arguments","children","stacks","Map","hasMounted","updateScheduled","renderScheduled","syncContext","createBatcher","syncUpdate","force","scheduleUpdate","forceUpdate","register","addChild","removeChild","__extends","prototype","componentDidMount","componentDidUpdate","startLayoutAnimation","shouldComponentUpdate","type","props","forEach","isPresent","Present","updateStacks","handler","layoutReady","getLayoutId","getStack","parent","context","visualElement","flush","resetRotate","hasRotate","resetValues","transformAxes","key","hasValue","getStaticValue","setStaticValue","syncRender","shouldResetTransform","resetTransform","snapshotViewportBox","addToStack","removeFromStack","id","has","render","React.createElement","SharedLayoutContext","Provider","contextType","MotionContext","React.Component","Component","TabLink","styled","NavLink","withConfig","componentId","s","hover","Active","m","div","stiffness","damping","Tab","exact","exactQueryString","rest","activeStyle","color","useTheme","textSecondary","match","location","isEqual","queryString","parse","search","jsx","layoutId","initial","Nav","nav","$shadowVisible","transparentize","theme","background","Sticky","span","Tabs","ref","React","shadowVisible","setShadow","width","useWindowSize","updateShadows","c","current","scrollLeft","fade","scrollWidth","clientWidth","onScroll"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}