{"version":3,"file":"Switch.3DOmHSIs.js","sources":["../../../app/utils/isTextInput.ts","../../../app/hooks/useKeyDown.ts","../../../app/components/Popover.tsx","../../../app/components/Icons/CollectionIcon.tsx","../../../app/components/Switch.tsx"],"sourcesContent":["const inputs = [\"input\", \"select\", \"button\", \"textarea\"]; // detect if node is a text input element\n\nexport default function isTextInput(element: Element): boolean {\n  return !!(\n    element &&\n    element.tagName &&\n    (inputs.indexOf(element.tagName.toLowerCase()) !== -1 ||\n      element.attributes.getNamedItem(\"role\")?.value === \"textbox\" ||\n      element.attributes.getNamedItem(\"contenteditable\")?.value === \"true\")\n  );\n}\n","import * as React from \"react\";\nimport { isModKey } from \"@shared/utils/keyboard\";\nimport isTextInput from \"~/utils/isTextInput\";\n\ntype Callback = (event: KeyboardEvent) => void;\n\nexport type KeyFilter = ((event: KeyboardEvent) => boolean) | string;\n\nexport type Options = {\n  allowInInput?: boolean;\n};\n\ntype RegisteredCallback = {\n  callback: Callback;\n  options?: Options;\n};\n\n// Registered keyboard event callbacks\nlet callbacks: RegisteredCallback[] = [];\n\n// Track if IME input suggestions are open so we can ignore keydown shortcuts\n// in this case, they should never be triggered from mobile keyboards.\nlet imeOpen = false;\n\n// Based on implementation in react-use\n// https://github.com/streamich/react-use/blob/master/src/useKey.ts#L15-L22\nconst createKeyPredicate = (keyFilter: KeyFilter) =>\n  typeof keyFilter === \"function\"\n    ? keyFilter\n    : typeof keyFilter === \"string\"\n    ? (event: KeyboardEvent) => event.key === keyFilter\n    : keyFilter\n    ? (_event: KeyboardEvent) => true\n    : (_event: KeyboardEvent) => false;\n\nexport default function useKeyDown(\n  key: KeyFilter,\n  fn: Callback,\n  options?: Options\n): void {\n  const predicate = createKeyPredicate(key);\n\n  React.useEffect(() => {\n    const handler = (event: KeyboardEvent) => {\n      if (predicate(event)) {\n        fn(event);\n      }\n    };\n\n    callbacks.push({\n      callback: handler,\n      options,\n    });\n\n    return () => {\n      callbacks = callbacks.filter((cb) => cb.callback !== handler);\n    };\n  }, [fn, predicate, options]);\n}\n\nwindow.addEventListener(\"keydown\", (event) => {\n  if (imeOpen) {\n    return;\n  }\n\n  // reverse so that the last registered callbacks get executed first\n  for (const registered of callbacks.reverse()) {\n    if (event.defaultPrevented === true) {\n      break;\n    }\n\n    if (\n      !isTextInput(event.target as HTMLElement) ||\n      registered.options?.allowInInput ||\n      isModKey(event)\n    ) {\n      registered.callback(event);\n    }\n  }\n});\n\nwindow.addEventListener(\"compositionstart\", () => {\n  imeOpen = true;\n});\n\nwindow.addEventListener(\"compositionend\", () => {\n  imeOpen = false;\n});\n","import * as React from \"react\";\nimport { Dialog } from \"reakit/Dialog\";\nimport { Popover as ReakitPopover, PopoverProps } from \"reakit/Popover\";\nimport styled from \"styled-components\";\nimport breakpoint from \"styled-components-breakpoint\";\nimport { depths, s } from \"@shared/styles\";\nimport useKeyDown from \"~/hooks/useKeyDown\";\nimport useMobile from \"~/hooks/useMobile\";\nimport { fadeAndScaleIn } from \"~/styles/animations\";\n\ntype Props = PopoverProps & {\n  children: React.ReactNode;\n  /** The width of the popover, defaults to 380px. */\n  width?: number;\n  /** The minimum width of the popover, use instead of width if contents adjusts size. */\n  minWidth?: number;\n  /** Shrink the padding of the popover */\n  shrink?: boolean;\n  /** Make the popover flex */\n  flex?: boolean;\n  /** The tab index of the popover */\n  tabIndex?: number;\n  /** Whether the popover should be scrollable, defaults to true. */\n  scrollable?: boolean;\n  /** The position of the popover on mobile, defaults to \"top\". */\n  mobilePosition?: \"top\" | \"bottom\";\n  /** Function to show the popover */\n  show: () => void;\n  /** Function to hide the popover */\n  hide: () => void;\n};\n\nconst Popover = (\n  {\n    children,\n    shrink,\n    width = 380,\n    minWidth,\n    scrollable = true,\n    flex,\n    mobilePosition,\n    ...rest\n  }: Props,\n  ref: React.Ref<HTMLDivElement>\n) => {\n  const isMobile = useMobile();\n\n  // Custom Escape handler rather than using hideOnEsc from reakit so we can\n  // prevent default behavior of exiting fullscreen.\n  useKeyDown(\n    \"Escape\",\n    (event) => {\n      if (rest.visible && rest.hideOnEsc !== false) {\n        event.preventDefault();\n        rest.hide();\n      }\n    },\n    {\n      allowInInput: true,\n    }\n  );\n\n  if (isMobile) {\n    return (\n      <Dialog {...rest} modal>\n        <Contents\n          ref={ref}\n          $shrink={shrink}\n          $scrollable={scrollable}\n          $flex={flex}\n          $mobilePosition={mobilePosition}\n        >\n          {children}\n        </Contents>\n      </Dialog>\n    );\n  }\n\n  return (\n    <StyledPopover {...rest} hideOnEsc={false} hideOnClickOutside>\n      <Contents\n        ref={ref}\n        $shrink={shrink}\n        $width={width}\n        $minWidth={minWidth}\n        $scrollable={scrollable}\n        $flex={flex}\n      >\n        {children}\n      </Contents>\n    </StyledPopover>\n  );\n};\n\ntype ContentsProps = {\n  $shrink?: boolean;\n  $width?: number;\n  $minWidth?: number;\n  $flex?: boolean;\n  $scrollable: boolean;\n  $mobilePosition?: \"top\" | \"bottom\";\n};\n\nconst StyledPopover = styled(ReakitPopover)`\n  z-index: ${depths.modal};\n`;\n\nconst Contents = styled.div<ContentsProps>`\n  display: ${(props) => (props.$flex ? \"flex\" : \"block\")};\n  animation: ${fadeAndScaleIn} 200ms ease;\n  transform-origin: 75% 0;\n  background: ${s(\"menuBackground\")};\n  border-radius: 6px;\n  padding: ${(props) => (props.$shrink ? \"6px 0\" : \"12px 24px\")};\n  max-height: 75vh;\n  box-shadow: ${s(\"menuShadow\")};\n  ${(props) => props.$width && `width: ${props.$width}px`};\n  ${(props) => props.$minWidth && `min-width: ${props.$minWidth}px`};\n\n  ${(props) =>\n    props.$scrollable\n      ? `\n      overflow-x: hidden;\n      overflow-y: auto;\n    `\n      : `\n      overflow: hidden;\n    `}\n\n  ${breakpoint(\"mobile\", \"tablet\")`\n    position: fixed;\n    z-index: ${depths.menu};\n\n    // 50 is a magic number that positions us nicely under the top bar\n    top: ${(props: ContentsProps) =>\n      props.$mobilePosition === \"bottom\" ? \"auto\" : \"50px\"};\n    bottom: ${(props: ContentsProps) =>\n      props.$mobilePosition === \"bottom\" ? \"0\" : \"auto\"};\n    left: 8px;\n    right: 8px;\n    width: auto;\n  `};\n`;\n\nexport default React.forwardRef(Popover);\n","import { observer } from \"mobx-react\";\nimport { CollectionIcon, PrivateCollectionIcon } from \"outline-icons\";\nimport { getLuminance } from \"polished\";\nimport * as React from \"react\";\nimport Icon from \"@shared/components/Icon\";\nimport { colorPalette } from \"@shared/utils/collections\";\nimport Collection from \"~/models/Collection\";\nimport useStores from \"~/hooks/useStores\";\n\ntype Props = {\n  /** The collection to show an icon for */\n  collection: Collection;\n  /** Whether the icon should be the \"expanded\" graphic when displaying the default collection icon */\n  expanded?: boolean;\n  /** The size of the icon, 24px is default to match standard icons */\n  size?: number;\n  /** The color of the icon, defaults to the collection color */\n  color?: string;\n  className?: string;\n};\n\nfunction ResolvedCollectionIcon({\n  collection,\n  color: inputColor,\n  expanded,\n  size,\n  className,\n}: Props) {\n  const { ui } = useStores();\n\n  if (!collection.icon || collection.icon === \"collection\") {\n    // If the chosen icon color is very dark then we invert it in dark mode\n    // otherwise it will be impossible to see against the dark background.\n    const collectionColor = collection.color ?? colorPalette[0];\n    const color =\n      inputColor ||\n      (ui.resolvedTheme === \"dark\" && collectionColor !== \"currentColor\"\n        ? getLuminance(collectionColor) > 0.09\n          ? collectionColor\n          : \"currentColor\"\n        : collectionColor);\n\n    const Component = collection.isPrivate\n      ? PrivateCollectionIcon\n      : CollectionIcon;\n    return (\n      <Component\n        color={color}\n        expanded={expanded}\n        size={size}\n        className={className}\n      />\n    );\n  }\n\n  return (\n    <Icon\n      value={collection.icon}\n      color={inputColor ?? collection.color ?? undefined}\n      size={size}\n      initial={collection.initial}\n      className={className}\n      forceColor={inputColor ? true : false}\n    />\n  );\n}\n\nexport default observer(ResolvedCollectionIcon);\n","import * as React from \"react\";\nimport styled from \"styled-components\";\nimport { s } from \"@shared/styles\";\nimport { LabelText } from \"~/components/Input\";\nimport Text from \"~/components/Text\";\nimport { undraggableOnDesktop } from \"~/styles\";\n\ninterface Props extends React.HTMLAttributes<HTMLInputElement> {\n  /** Width of the switch. Defaults to 32. */\n  width?: number;\n  /** Height of the switch. Defaults to 18 */\n  height?: number;\n  /** An optional label for the switch */\n  label?: string;\n  /** Whether the label should be positioned on left or right. Defaults to right */\n  labelPosition?: \"left\" | \"right\";\n  /** An optional note to display below the switch */\n  note?: React.ReactNode;\n  /** Name of the input */\n  name?: string;\n  /** Whether the switch is checked */\n  checked?: boolean;\n  /** Whether the switch is disabled */\n  disabled?: boolean;\n}\n\nfunction Switch(\n  {\n    width = 32,\n    height = 18,\n    labelPosition = \"left\",\n    label,\n    disabled,\n    className,\n    note,\n    ...props\n  }: Props,\n  ref: React.Ref<HTMLInputElement>\n) {\n  const component = (\n    <Input\n      width={width}\n      height={height}\n      className={label ? undefined : className}\n    >\n      <HiddenInput\n        ref={ref}\n        type=\"checkbox\"\n        width={width}\n        height={height}\n        disabled={disabled}\n        {...props}\n      />\n      <Slider width={width} height={height} />\n    </Input>\n  );\n\n  if (label) {\n    return (\n      <Wrapper>\n        <Label\n          disabled={disabled}\n          htmlFor={props.id}\n          className={className}\n          $labelPosition={labelPosition}\n        >\n          {component}\n          <InlineLabelText>{label}</InlineLabelText>\n        </Label>\n        {note && (\n          <Text\n            type=\"secondary\"\n            size=\"small\"\n            style={{\n              paddingRight: labelPosition === \"left\" ? width : 0,\n              paddingLeft: labelPosition === \"right\" ? width : 0,\n            }}\n          >\n            {note}\n          </Text>\n        )}\n      </Wrapper>\n    );\n  }\n\n  return component;\n}\n\nconst Wrapper = styled.div`\n  padding-bottom: 8px;\n  ${undraggableOnDesktop()}\n`;\n\nconst InlineLabelText = styled(LabelText)`\n  padding-bottom: 0;\n  width: 100%;\n`;\n\nconst Label = styled.label<{\n  disabled?: boolean;\n  $labelPosition: \"left\" | \"right\";\n}>`\n  display: flex;\n  align-items: center;\n  user-select: none;\n  gap: 8px;\n\n  ${(props) =>\n    props.$labelPosition === \"left\" ? `flex-direction: row-reverse;` : \"\"}\n  ${(props) => (props.disabled ? `opacity: 0.75;` : \"\")}\n`;\n\nconst Input = styled.label<{ width: number; height: number }>`\n  position: relative;\n  display: inline-block;\n  width: ${(props) => props.width}px;\n  height: ${(props) => props.height}px;\n  flex-shrink: 0;\n`;\n\nconst Slider = styled.span<{ width: number; height: number }>`\n  position: absolute;\n  cursor: var(--pointer);\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: ${(props) => props.theme.slate};\n  -webkit-transition: 0.4s;\n  transition: 0.4s;\n  border-radius: ${(props) => props.height}px;\n\n  &:before {\n    position: absolute;\n    content: \"\";\n    height: ${(props) => props.height - 8}px;\n    width: ${(props) => props.height - 8}px;\n    left: 4px;\n    bottom: 4px;\n    background-color: white;\n    border-radius: 50%;\n    -webkit-transition: 0.4s;\n    transition: 0.4s;\n  }\n`;\n\nconst HiddenInput = styled.input<{ width: number; height: number }>`\n  opacity: 0;\n  width: 0;\n  height: 0;\n  visibility: hidden;\n\n  &:disabled + ${Slider} {\n    opacity: 0.75;\n    cursor: default;\n  }\n\n  &:checked + ${Slider} {\n    background-color: ${s(\"accent\")};\n  }\n\n  &:focus + ${Slider} {\n    box-shadow: 0 0 1px ${s(\"accent\")};\n  }\n\n  &:checked + ${Slider}:before {\n    transform: translateX(${(props) => props.width - props.height}px);\n  }\n`;\n\nexport default React.forwardRef(Switch);\n"],"names":["inputs","callbacks","imeOpen","useKeyDown","key","fn","options","predicate","keyFilter","event","_event","createKeyPredicate","React","handler","push","callback","filter","cb","window","addEventListener","element","registered","reverse","defaultPrevented","target","tagName","indexOf","toLowerCase","attributes","getNamedItem","value","allowInInput","isModKey","StyledPopover","styled","ReakitPopover","withConfig","componentId","depths","modal","Contents","div","props","$flex","fadeAndScaleIn","s","$shrink","$width","$minWidth","$scrollable","breakpoint","menu","$mobilePosition","Popover","children","shrink","width","minWidth","scrollable","flex","mobilePosition","rest","ref","isMobile","useMobile","visible","hideOnEsc","preventDefault","hide","Dialog","jsx","hideOnClickOutside","observer","ResolvedCollectionIcon","collection","color","inputColor","expanded","size","className","ui","useStores","icon","collectionColor","colorPalette","resolvedTheme","getLuminance","Component","isPrivate","PrivateCollectionIcon","CollectionIcon","Icon","undefined","initial","forceColor","Wrapper","undraggableOnDesktop","InlineLabelText","LabelText","Label","label","$labelPosition","disabled","Input","height","Slider","span","theme","slate","HiddenInput","input","Switch","labelPosition","note","component","jsxs","type","htmlFor","id","Text","style","paddingRight","paddingLeft"],"mappings":"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"}