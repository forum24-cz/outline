{"version":3,"mappings":";gOA2BO,SAASA,iBAA0CC,KACxDA,OACAC,QACAC,YACAC,IAEA,MAAOC,EAAOC,GAAYC,EAAMC,YACzBC,EAAQC,GAAaH,EAAMC,SAAS,CAAEG,MAxBxB,IAyBfC,EAAgBL,EAAMM,OAAOT,GAC7BU,EAAUP,EAAMM,OAAmBX,GAEnCa,EAAYR,EAAMS,aACtB,IAAMb,EAAM,IAAKC,EAAWK,OAAQA,EAAOE,MAAOM,MA5BpC,MA6Bd,CAACd,EAAOC,EAAWK,KAGfS,QAAEA,UAASC,QAASC,GAAUC,EAAWN,GAEzCO,EAAWf,EAAMS,aACrB,IACEN,GAAqBa,IAAA,CACnBZ,MAAOY,EAAKZ,MArCF,QAuCd,IAGIa,EAAavB,EACfwB,EAAQxB,EAAMa,EAAQY,QAAQC,GAAIb,EAAQY,QAAQE,KAAO,OAAS,YAClEC,EAEEC,GACHX,GAAWd,GAASmB,GAAcA,EAAWO,OAAS1B,EACnDiB,OACAO,EA4BC,OA1BPtB,EAAMyB,WAAU,KACVpB,KAAcc,UAAYtB,EAG5B,OAFAQ,EAAcc,QAAUtB,OACdM,EAAA,CAAEC,MAvDK,IA2DnB,IAAIsB,GAAS,EAcb,MAZsBC,WACdC,cAAiBjB,IAClBiB,IAAYF,IAIjBnB,EAAQY,QAAUxB,EACTiC,IAASC,IAAoB/B,OAAK,EAGxCgC,GAEE,KACIJ,GAAA,KAEV,CAAC/B,EAAME,EAAWK,EAAQS,IAEtB,CACLjB,KAAMuB,EACNJ,QACAD,UACAW,OAEJ,CCvFA,MAAMQ,EAAQC,GAAc,WAAMC,OAAO,wBAAqBC,gCAIvD,SAASC,cAAiBC,GAC/B,MAAMC,EAAWC,IACXC,EAAUC,IACVC,EAASC,IAETC,EAAmB3C,eACtBL,IACQiD,MAAI,OAAQjD,EAAKyB,IACxBqB,EAAOG,IAAI,YAAajD,EAAK0B,KAAO,OAAS,OAE7CkB,EAAQM,QAAQ,CACdC,SAAUT,EAASS,SACnBC,OAAQN,EAAOO,YAChB,GAEH,CAACP,EAAQF,EAASF,EAASS,WAG7B,SAAQf,EAAA,CAAMkB,aAAcN,KAAsBP,GACpD,CCzBO,MAAMc,EAAgB,GAEhBC,EAAgBC,EAAOC,GAAKC,WAAA,CAAAC,YAAA,eAAZH,CAAY,uEAFZ,GAKpBI,EACIC,EAAOC,OACJC,EAAE","names":["useTableRequest","data","sort","reqFn","reqParams","total","setTotal","React","useState","offset","setOffset","value","prevParamsRef","useRef","sortRef","fetchPage","useCallback","limit","request","loading","error","useRequest","nextPage","prev","sortedData","orderBy","current","id","desc","undefined","next","length","useEffect","ignore","async","response","PAGINATION_SYMBOL","handleRequest","Table","lazyWithRetry","import","__VITE_PRELOAD__","SortableTable","props","location","useLocation","history","useHistory","params","useQuery","handleChangeSort","set","replace","pathname","search","toString","onChangeSort","FILTER_HEIGHT","StickyFilters","styled","Flex","withConfig","componentId","HEADER_HEIGHT","depths","header","s"],"ignoreList":[],"sources":["../../../app/hooks/useTableRequest.ts","../../../app/components/SortableTable.tsx","../../../app/scenes/Settings/components/StickyFilters.tsx"],"sourcesContent":["import { ColumnSort } from \"@tanstack/react-table\";\nimport orderBy from \"lodash/orderBy\";\nimport React from \"react\";\nimport {\n  FetchPageParams,\n  PaginatedResponse,\n  PAGINATION_SYMBOL,\n} from \"~/stores/base/Store\";\nimport useRequest from \"./useRequest\";\n\nconst INITIAL_OFFSET = 0;\nconst PAGE_SIZE = 25;\n\ntype Props<T> = {\n  data: T[];\n  sort: ColumnSort;\n  reqFn: (params: FetchPageParams) => Promise<PaginatedResponse<T>>;\n  reqParams: Omit<FetchPageParams, \"offset\" | \"limit\">;\n};\n\ntype Response<T> = {\n  data: T[] | undefined;\n  error: unknown;\n  loading: boolean;\n  next: (() => void) | undefined;\n};\n\nexport function useTableRequest<T extends { id: string }>({\n  data,\n  sort,\n  reqFn,\n  reqParams,\n}: Props<T>): Response<T> {\n  const [total, setTotal] = React.useState<number>();\n  const [offset, setOffset] = React.useState({ value: INITIAL_OFFSET });\n  const prevParamsRef = React.useRef(reqParams);\n  const sortRef = React.useRef<ColumnSort>(sort);\n\n  const fetchPage = React.useCallback(\n    () => reqFn({ ...reqParams, offset: offset.value, limit: PAGE_SIZE }),\n    [reqFn, reqParams, offset]\n  );\n\n  const { request, loading, error } = useRequest(fetchPage);\n\n  const nextPage = React.useCallback(\n    () =>\n      setOffset((prev) => ({\n        value: prev.value + PAGE_SIZE,\n      })),\n    []\n  );\n\n  const sortedData = data\n    ? orderBy(data, sortRef.current.id, sortRef.current.desc ? \"desc\" : \"asc\")\n    : undefined;\n\n  const next =\n    !loading && total && sortedData && sortedData.length < total\n      ? nextPage\n      : undefined;\n\n  React.useEffect(() => {\n    if (prevParamsRef.current !== reqParams) {\n      prevParamsRef.current = reqParams;\n      setOffset({ value: INITIAL_OFFSET });\n      return;\n    }\n\n    let ignore = false;\n\n    const handleRequest = async () => {\n      const response = await request();\n      if (!response || ignore) {\n        return;\n      }\n\n      sortRef.current = sort; // Change sort once we receive a response from server - avoids flicker with stale data.\n      setTotal(response[PAGINATION_SYMBOL]?.total);\n    };\n\n    void handleRequest();\n\n    return () => {\n      ignore = true;\n    };\n  }, [sort, reqParams, offset, request]);\n\n  return {\n    data: sortedData,\n    error,\n    loading,\n    next,\n  };\n}\n","import { ColumnSort } from \"@tanstack/react-table\";\nimport * as React from \"react\";\nimport { useHistory, useLocation } from \"react-router-dom\";\nimport useQuery from \"~/hooks/useQuery\";\nimport lazyWithRetry from \"~/utils/lazyWithRetry\";\nimport type { Props as TableProps } from \"./Table\";\n\nconst Table = lazyWithRetry(() => import(\"~/components/Table\"));\n\nexport type Props<T> = Omit<TableProps<T>, \"onChangeSort\">;\n\nexport function SortableTable<T>(props: Props<T>) {\n  const location = useLocation();\n  const history = useHistory();\n  const params = useQuery();\n\n  const handleChangeSort = React.useCallback(\n    (sort: ColumnSort) => {\n      params.set(\"sort\", sort.id);\n      params.set(\"direction\", sort.desc ? \"desc\" : \"asc\");\n\n      history.replace({\n        pathname: location.pathname,\n        search: params.toString(),\n      });\n    },\n    [params, history, location.pathname]\n  );\n\n  return <Table onChangeSort={handleChangeSort} {...props} />;\n}\n","import styled from \"styled-components\";\nimport { depths, s } from \"@shared/styles\";\nimport Flex from \"~/components/Flex\";\nimport { HEADER_HEIGHT } from \"~/components/Header\";\n\nexport const FILTER_HEIGHT = 40;\n\nexport const StickyFilters = styled(Flex)`\n  height: ${FILTER_HEIGHT}px;\n  position: sticky;\n  top: ${HEADER_HEIGHT}px;\n  z-index: ${depths.header};\n  background: ${s(\"background\")};\n`;\n"],"file":"assets/StickyFilters.abAWg0uL.js"}