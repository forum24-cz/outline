"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _emojiRegex = _interopRequireDefault(require("emoji-regex"));
var _truncate = _interopRequireDefault(require("lodash/truncate"));
var _parseTitle = _interopRequireDefault(require("./../../shared/utils/parseTitle"));
var _validations = require("./../../shared/validations");
var _tracing = require("./../logging/tracing");
var _ProsemirrorHelper = require("./../models/helpers/ProsemirrorHelper");
var _TextHelper = require("./../models/helpers/TextHelper");
var _DocumentConverter = require("./../utils/DocumentConverter");
var _errors = require("../errors");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
async function documentImporter(_ref) {
  let {
    mimeType,
    fileName,
    content,
    user,
    ctx
  } = _ref;
  let text = await _DocumentConverter.DocumentConverter.convertToMarkdown(content, fileName, mimeType);
  let title = fileName.replace(/\.[^/.]+$/, "");

  // find and extract emoji near the beginning of the document.
  const regex = (0, _emojiRegex.default)();
  const matches = regex.exec(text.slice(0, 10));
  const icon = matches ? matches[0] : undefined;
  if (icon) {
    text = text.replace(icon, "");
  }

  // If the first line of the imported text looks like a markdown heading
  // then we can use this as the document title rather than the file name.
  if (text.trim().startsWith("# ")) {
    const result = (0, _parseTitle.default)(text);
    title = result.title;
    text = text.replace(/^.+(\n|$)/, "");
  }

  // Replace any <br> generated by the turndown plugin with escaped newlines
  // to match our hardbreak parser.
  text = text.trim().replace(/<br>/gi, "\\n");

  // Remove any closed and immediately reopened formatting marks
  text = text.replace(/\*\*\*\*/gi, "").replace(/____/gi, "");
  text = await _TextHelper.TextHelper.replaceImagesWithAttachments(ctx, text, user);

  // Sanity check â€“ text cannot possibly be longer than state so if it is, we can short-circuit here
  if (text.length > _validations.DocumentValidation.maxStateLength) {
    throw (0, _errors.InvalidRequestError)(`The document "${title}" is too large to import, please reduce the length and try again`);
  }

  // It's better to truncate particularly long titles than fail the import
  title = (0, _truncate.default)(title, {
    length: _validations.DocumentValidation.maxTitleLength
  });
  const ydoc = _ProsemirrorHelper.ProsemirrorHelper.toYDoc(text);
  const state = _ProsemirrorHelper.ProsemirrorHelper.toState(ydoc);
  if (state.length > _validations.DocumentValidation.maxStateLength) {
    throw (0, _errors.InvalidRequestError)(`The document "${title}" is too large to import, please reduce the length and try again`);
  }
  return {
    text,
    state,
    title,
    icon
  };
}
var _default = exports.default = (0, _tracing.traceFunction)({
  spanName: "documentImporter"
})(documentImporter);